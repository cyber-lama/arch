# SOLID принципы

- [Принцип единственной ответственности](#srp)
- [Принцип открытости/закрытости](#ocp)


## srp

**Принцип единственной ответственности**

Для каждого класса должно быть определено единственное назначение. 
Все ресурсы, необходимые для его осуществления, 
должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Пример нарушения принципа на typescript:
```typescript
class UserManager
{
    public writeToFile() {}
    public calculatePaymentAmount() {}
    public authenticateUser() {}
}
```
Принцип единственной ответственности возник 
как попытка объединения двух важных понятий структурного 
анализа и проектирования: coupling 
(сопряжение, зацепление, связанность) 
и cohesion (сплочённость, связность, прочность модуля).

### Связность (от худшего к лучшему)

#### Случайная
Подмодули модуля в этом случае никак не взаимодействуют друг с другом и выполняют функционально не связанные задачи. Примером такой связности может быть весь тот код, который часто приводят для демонстрации нарушения принципа единственной ответственности.
Пример выше описывает именно такую связанность.

#### Логическая
Также как и в случае случайной связности подмодули модуля никак не взаимодействуют друг с другом (либо взаимодействуют слабо), однако наблюдается их логическое сходство по какому-либо признаку (например, по сходству решаемых подмодулями задач).
#### Временная
Тип связности при котором подмодули объединены в модуль по причине их совместного использования в некоторый момент времени выполнения программы, а порядок обращения к ним не важен. При этом подмодули никак функционально не связаны между собой.
#### Процедурная
Тип связности при котором подмодули объединены в модуль по причине их совместного использования в некоторый момент времени выполнения программы. Обращение к модулям происходит в определённом порядке. Подмодули могут быть функционально связаны между собой.
#### Коммуникационная/информационная
Подмодули модуля функционально связаны между собой и обрабатывают одни и те же данные. Порядок обращения к подмодулям не имеет значения.
#### Последовательностная
Подмодули модуля функционально связаны между собой. При этом выходные данные одного подмодуля становятся входными данными другого подмодуля, т.е. важен порядок обращения к подмодулям. Как правило такой модуль имеет одну точку входа.
```typescript
class ExpressionExecutor
{
    public execute(str: string) {
        const ast = this.parse(
            this.lexer(
                this.characterIterator($expression)
            )
        );
        return ast.evaluate();
    }

    protected parse(lexer: string) {}
    protected lexer(Iterator: string): Lexer {}
    protected characterIterator(expression): Iterator {} 
}
```
#### Функциональная
Все подмодули модуля функционально связаны между собой и выполняют одну хорошо определённую задачу. Этот тип связности прямая противоположность случайной связности.
```typescript
class Lexer
{
    public  construct(charIterator: CharacterIterator) {}
    public  getTokens(): Generator {}
}
```

### Сопряжение (от худшего к лучшему)

#### Патологическое (pathological)
Программный модуль оказывает влияние или зависит от внутренней реализации другого модуля. Как правило, этот тип зацепления связан с нарушением принципа сокрытия информации

#### По содержимому
Часть или все содержимое одного программного модуля включены в содержимое другого модуля. Примером такого зацепления могут служить вложенные или анонимные классы.

#### По общей области данных (common, common-environment)
Два или более модулей совместно используют общую область данных (глобальную по отношению к модулям).

#### Смешанное (hybrid)
Различные подмножества значений некоторого элемента данных используются в нескольких программных модулях для разных и несвязанных целей. Тут можно придумать такой искусственный пример: есть некоторый DTO содержащий данные потребляемыми двумя совершенно разными модулями.

#### По управлению (control coupling)
Один модуль взаимодействует с другим модулем с целью повлиять на его поведение путём передачи ему управляющей информации.

#### По данным (data)
Данные одного программного модуля поступают на вход другого модуля.


## ocp

**Принцип открытости/закрытости**

Принцип открытости/закрытости означает, что программные сущности должны быть:

- открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых типов сущностей.
- закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эту сущность использует.

Пример нарушения принципа открытости/закрытости

```typescript
class Rectangle {
  public width: number;
  public height: number;

  public calculateArea(): number {
    return this.width * this.height;
  }
}

class Circle {
  public radius: number;

  public calculateArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class AreaCalculator {
  public calculateTotalArea(shapes: Array<Rectangle | Circle>): number {
    let totalArea = 0;
    for (const shape of shapes) {
        if (shape instanceof Rectangle) {
          totalArea += shape.width * shape.height;
        } else if (shape instanceof Circle) {
          totalArea += Math.PI * shape.radius * shape.radius;
        }
    }
    return totalArea;
  }
}

```

В этом примере AreaCalculatorкласс отвечает за вычисление общей площади набора фигур. Однако это достигается за счет жесткого кодирования конкретных реализаций calculateArea()метода для классов Rectangleи . CircleЭто означает, что если мы хотим добавить новую форму, нам нужно изменить AreaCalculatorкласс, нарушив принцип открытости/закрытости.

Более правильным будет сделать так:
```typescript
interface Shape {
  calculateArea(): number;
}

class Rectangle implements Shape {
  public width: number;
  public height: number;

  public calculateArea(): number {
    return this.width * this.height;
  }
}

class Circle implements Shape {
  public radius: number;

  public calculateArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class AreaCalculator {
  public calculateTotalArea(shapes: Array<Shape>): number {
    let totalArea = 0;
    for (const shape of shapes) {
        totalArea += shape.calculateArea();
    }
    return totalArea;
  }
}

```