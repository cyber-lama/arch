# SOLID принципы

- [Принцип единственной ответственности](#srp)


## srp

**Принцип единственной ответственности**

Для каждого класса должно быть определено единственное назначение. 
Все ресурсы, необходимые для его осуществления, 
должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Пример нарушения принципа на typescript:
```typescript
class UserManager
{
    public writeToFile() {}
    public calculatePaymentAmount() {}
    public authenticateUser() {}
}
```
Принцип единственной ответственности возник 
как попытка объединения двух важных понятий структурного 
анализа и проектирования: coupling 
(сопряжение, зацепление, связанность) 
и cohesion (сплочённость, связность, прочность модуля).

### Связность (от худшего к лучшему)

#### Случайная
Подмодули модуля в этом случае никак не взаимодействуют друг с другом и выполняют функционально не связанные задачи. Примером такой связности может быть весь тот код, который часто приводят для демонстрации нарушения принципа единственной ответственности.
Пример выше описывает именно такую связанность.

#### Логическая
Также как и в случае случайной связности подмодули модуля никак не взаимодействуют друг с другом (либо взаимодействуют слабо), однако наблюдается их логическое сходство по какому-либо признаку (например, по сходству решаемых подмодулями задач).
#### Временная
Тип связности при котором подмодули объединены в модуль по причине их совместного использования в некоторый момент времени выполнения программы, а порядок обращения к ним не важен. При этом подмодули никак функционально не связаны между собой.
#### Процедурная
Тип связности при котором подмодули объединены в модуль по причине их совместного использования в некоторый момент времени выполнения программы. Обращение к модулям происходит в определённом порядке. Подмодули могут быть функционально связаны между собой.
#### Коммуникационная/информационная
Подмодули модуля функционально связаны между собой и обрабатывают одни и те же данные. Порядок обращения к подмодулям не имеет значения.
#### Последовательностная
Подмодули модуля функционально связаны между собой. При этом выходные данные одного подмодуля становятся входными данными другого подмодуля, т.е. важен порядок обращения к подмодулям. Как правило такой модуль имеет одну точку входа.
```typescript
class ExpressionExecutor
{
    public execute(str: string) {
        const ast = this.parse(
            this.lexer(
                this.characterIterator($expression)
            )
        );
        return ast.evaluate();
    }

    protected parse(lexer: string) {}
    protected lexer(Iterator: string): Lexer {}
    protected characterIterator(expression): Iterator {} 
}
```
#### Функциональная
Все подмодули модуля функционально связаны между собой и выполняют одну хорошо определённую задачу. Этот тип связности прямая противоположность случайной связности.
```typescript
class Lexer
{
    public  construct(charIterator: CharacterIterator) {}
    public  getTokens(): Generator {}
}
```

### Сопряжение (от худшего к лучшему)

#### Патологическое (pathological)
Программный модуль оказывает влияние или зависит от внутренней реализации другого модуля. Как правило, этот тип зацепления связан с нарушением принципа сокрытия информации

#### По содержимому
Часть или все содержимое одного программного модуля включены в содержимое другого модуля. Примером такого зацепления могут служить вложенные или анонимные классы.

#### По общей области данных (common, common-environment)
Два или более модулей совместно используют общую область данных (глобальную по отношению к модулям).

#### Смешанное (hybrid)
Различные подмножества значений некоторого элемента данных используются в нескольких программных модулях для разных и несвязанных целей. Тут можно придумать такой искусственный пример: есть некоторый DTO содержащий данные потребляемыми двумя совершенно разными модулями.

#### По управлению (control coupling)
Один модуль взаимодействует с другим модулем с целью повлиять на его поведение путём передачи ему управляющей информации.

#### По данным (data)
Данные одного программного модуля поступают на вход другого модуля.
